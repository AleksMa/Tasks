(define break #f)
(call-with-current-continuation
 (lambda (k) (set! break k)))


(define (make-source sequence . end)
  (define xs (cond ((list? sequence) sequence)
                   ((vector? sequence) (vector->list sequence))
                   ((string? sequence) (string->list sequence))))
  (define eot (if (pair? end)
                  (car end)
                  #f)) 
  (list->vector (cons 2 (cons eot xs))))

(define (peek vs)
  (if (= (vector-ref vs 0) (vector-length vs))
      (vector-ref vs 1)
      (vector-ref vs (vector-ref vs 0))))

(define (next vs)
  (if (= (vector-ref vs 0) (vector-length vs))
      (vector-ref vs 1)
      (begin
        (vector-set! vs 0 (+ 1 (vector-ref vs 0))) 
        (vector-ref vs (- (vector-ref vs 0) 1)))))

(define (space? sym) 
  (or (eq? #\tab sym)
      (eq? #\space sym)
      (eq? #\newline sym)))

(define (int? num)
  (or (eq? #\1 num)
      (eq? #\2 num)
      (eq? #\3 num)
      (eq? #\4 num)
      (eq? #\5 num)
      (eq? #\6 num)
      (eq? #\7 num)
      (eq? #\8 num)
      (eq? #\9 num)
      (eq? #\0 num)
      (eq? #\. num)))

(define (bracket? sym)
  (or (eq? #\( sym)
      (eq? #\) sym)))

(define (op? sym)
  (or (eq? #\- sym)
      (eq? #\+ sym)
      (eq? #\* sym)
      (eq? #\/ sym)
      (eq? #\^ sym)))
(define (AddOp? sym)
  (or (eq? #\- sym)
      (eq? #\+ sym)))
(define (MulOp? sym)
  (or (eq? #\/ sym)
      (eq? #\* sym )))
(define (E? sym)
  (or
   (eq? sym #\e)
   (eq? sym #\E)))


;Lexer
(define (tokenize str)
  (define src (make-source str))
  (define (lexer xs var num)
    (cond ((and (pair? num) (or (not (peek src)) (and
                                                  (not (int? (peek src)))
                                                  (not (E? (peek src)))
                                                  (not (and (AddOp? (peek src))
                                                            (E? (car num)))))))
           (lexer (cons (string->number (list->string (reverse num))) xs) var '()))
           ;(reverse num))
          ((and (pair? var) (or (not (peek src)) (not (char-alphabetic? (peek src)))))
           (lexer (cons (string->symbol (list->string (reverse var))) xs) '() num))
          ((not (peek src)) (reverse xs))
          ((and (E? (peek src))
                (pair? num))
           (lexer xs var (cons (next src) num)))
          ((and (AddOp? (peek src))
                (pair? num))
           (lexer xs var (cons (next src) num)))
          ((char-alphabetic? (peek src))
           (lexer xs (cons (next src) var) num))
          ((int? (peek src))
           (lexer xs var (cons (next src) num)))
          ((bracket? (peek src))
           (lexer (cons (string (next src)) xs) var num))
          ((op? (peek src))
           (lexer (cons (string->symbol (string (next src))) xs) var num))
          ((space? (peek src))
           (begin
             (next src)
             (lexer xs var num)))
          (else #f)))
  (lexer '() '() '()))

;Expr    ::= Term Expr' .
;Expr'   ::= AddOp Term Expr' | .
;Term    ::= Factor Term' .
;Term'   ::= MulOp Factor Term' | .
;Factor  ::= Power Factor' .
;Factor' ::= PowOp Power Factor' | .
;Power   ::= value | "(" Expr ")" | unaryMinus Power .

(define (AddOp? sym)
  (or (eq? '- sym)
      (eq? '+ sym)))
(define (MulOp? sym)
  (or (eq? '/ sym)
      (eq? '* sym)))

;Parser
(define (parse tokens)
  (let* ((src (make-source tokens))
         (tree (parse-expr src)))
    `( ,@tree)))

;Expr    ::= Term Expr' .
(define src '())
(define (parse-expr src)
  (let* ((term (parse-term src))
         (exprs (parse-exprs src)))
    (if (null? exprs)
        term
        `(,@term ,@exprs))))
;Expr'   ::= AddOp Term Expr' | .
(define (parse-exprs src)
  (if (not (peek src))
      '()
      (if (AddOp? (peek src))
          (let* ((op (next src))
                 (term (parse-term src))
                 (exprs (parse-exprs src)))
            (if (null? exprs)
                `(,op ,@term)
                `(,op ,@term ,@exprs)))
          (begin (write 'lol1)
                 (write src)))))
 ;Term    ::= Factor Term' .               
(define (parse-term src)
  (let* ((factor (parse-factor src))
         (terms (parse-terms src)))
    (if (null? terms)
        factor
        `(,@factor ,@terms))))
;Term'   ::= MulOp Factor Term' | .
(define (parse-terms src)
  (if (not (peek src))
      '()
      (if (MulOp? (peek src))
          (let* ((op (next src))
                 (factor (parse-factor src))
                 (terms (parse-terms src)))
            (if (null? terms)
                `(,op ,@factor)
                `(,op ,@factor ,@terms)))
          (begin (write 'lol2)
                 (write src)))))
;Factor  ::= Power Factor' .
(define (parse-factor src)
  (let* ((power (parse-power src))
         (factors (parse-factors src)))
    (if (null? factors)
        `(,@power ,@factors)
        power)))
;Factor' ::= PowOp Power Factor' | .
(define (parse-factors src)
  (if (not (peek src))
      '()
      (if (eq? (peek src) '^)
          (let* ((op (next src))
                 (power (parse-power src))
                 (factors (parse-factors src)))
            (if (null? factors)
                `(,op ,@power)
                `(,op ,@power ,@factors)))
          (begin (write 'lol3)
                 (write src)))))

(define (parse-factor src)
    (let ((res (parse-power src)))
      (if (equal? (peek src) '^)
          (list res (next src) (parse-factor src))
          res)))
;Power   ::= value | "(" Expr ")" | unaryMinus Power .
(define (parse-power src)
  (cond ((eq? (peek src) '-)
         (let* ((minus (next src))
                (power (parse-power src)))
           (list minus (parse-power src))))
        ((eq? (peek src) "(" )
         (begin
           (let* ((f (next src))
                  (expr (parse-expr src))
                  (l (next src)))
             (list expr))))
        ((or (number? (peek src))
             (and (symbol? (peek src))
                  (not (AddOp? (peek src)))
                  (not (MulOp? (peek src)))))
         (next src))
        (else 'lol)))